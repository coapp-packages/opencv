\ifCpp

\section{Per-element Operations}

%can't make cvCppFunc work with underscore (even as \_)
\cvfunc{cv::gpu::bitwise\_not}
Performs per-element bitwise inversion.

\cvdefCpp{void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for asynchronous version.}
\end{description}
See also: \hyperref[cppfunc.bitwise.not]{cv::bitwise\_not}.

\cvfunc{cv::gpu::bitwise\_or}
Performs per-element bitwise disjunction of two matrixes.

\cvdefCpp{void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{The first source matrix.}
\cvarg{src2}{The second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for asynchronous version.}
\end{description}
See also: \hyperref[cppfunc.bitwise.or]{cv::bitwise\_or}.

\cvfunc{cv::gpu::bitwise\_and}
Performs per-element bitwise conjunction of two matrixes.

\cvdefCpp{void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{The first source matrix.}
\cvarg{src2}{The second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for asynchronous version.}
\end{description}
See also: \hyperref[cppfunc.bitwise.and]{cv::bitwise\_and}.

\cvfunc{cv::gpu::bitwise\_xor}
Performs per-element bitwise "exclusive or" of two matrixes.

\cvdefCpp{void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{The first source matrix.}
\cvarg{src2}{The second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for asynchronous version.}
\end{description}
See also: \hyperref[cppfunc.bitwise.xor]{cv::bitwise\_xor}.

\section{Image Processing}

\cvCppFunc{gpu::meanShiftFiltering}
Performs mean-shift filtering.

\cvdefCpp{void meanShiftFiltering(const GpuMat\& src, GpuMat\& dst,\par
  int sp, int sr,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and type as \texttt{src}. Each pixel \texttt{(x,y)} of the destination image will contain color of converged point started from \texttt{(x,y)} pixel of the source image.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}

\cvCppFunc{gpu::meanShiftProc}
Performs mean-shift procedure and stores information about converged points in two images..

\cvdefCpp{void meanShiftProc(const GpuMat\& src, GpuMat\& dstr, GpuMat\& dstsp,\par
  int sp, int sr,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dstr}{Destination image. Will have the same size and type as \texttt{src}. Each pixel \texttt{(x,y)} of the destination image will contain color of converged point started from \texttt{(x,y)} pixel of the source image.}
\cvarg{dstsp}{16SC2 matrix, which will contain coordinates of converged points and have the same size as \texttt{src}.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}

\cvCppFunc{gpu::meanShiftSegmentation}
Performs mean-shift segmentation of the source image and eleminates small segments.

\cvdefCpp{void meanShiftSegmentation(const GpuMat\& src, Mat\& dst,\par
  int sp, int sr, int minsize,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dst}{Segmented image. Will have the same size and type as \texttt{src}.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{minsize}{Minimum segment size. Smaller segements will be merged.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}

\cvCppFunc{gpu::integral}
Computes the integral image and squared integral image.

\cvdefCpp{void integral(const GpuMat\& src, GpuMat\& sum);\newline
void integral(const GpuMat\& src, GpuMat\& sum, GpuMat\& sqsum);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 images are supported for now.}
\cvarg{sum}{Integral image. Will contain 32-bit unsigned integer values packed into 32SC1.}
\cvarg{sqsum}{Squared integral image. Will have 32FC1 type.}
\end{description}
See also: \cvCppCross{integral}.

\cvCppFunc{gpu::sqrIntegral}
Computes squared integral image.

\cvdefCpp{void sqrIntegral(const GpuMat\& src, GpuMat\& sqsum);}
\begin{description}
\cvarg{src}{Source image. Only 8UC1 images are supported for now.}
\cvarg{sqsum}{Squared integral image. Will contain 64-bit floating point values packed into 64U.}
\end{description}

\cvCppFunc{gpu::columnSum}
Computes vertical (column) sum.

\cvdefCpp{void columnSum(const GpuMat\& src, GpuMat\& sum);}
\begin{description}
\cvarg{src}{Source image. Only 32FC1 images are supported for now.}
\cvarg{sum}{Destination image. Will have 32FC1 type.}
\end{description}

\cvCppFunc{gpu::cornerHarris}
Computes Harris cornerness criteria at each image pixel.

\cvdefCpp{void cornerHarris(const GpuMat\& src, GpuMat\& dst,\par
  int blockSize, int ksize, double k,\par
  int borderType=BORDER\_REFLECT101);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 and 32FC1 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and 32FC1 type and contain cornerness values.}
\cvarg{blockSize}{Neighborhood size.}
\cvarg{ksize}{Aperture parameter for the Sobel operator.}
\cvarg{k}{Harris detector free parameter.}
\cvarg{borderType}{Pixel extrapolation method. Only \texttt{BORDER\_REFLECT101} and \texttt{BORDER\_REPLICATE} are supported for now.}
\end{description}
See also: \cvCppCross{cornerHarris}.

\cvCppFunc{gpu::cornerMinEigenVal}
Computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness criteria.

\cvdefCpp{void cornerMinEigenVal(const GpuMat\& src, GpuMat\& dst,\par
  int blockSize, int ksize,\par
  int borderType=BORDER\_REFLECT101);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 and 32FC1 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and 32FC1 type and contain cornerness values.}
\cvarg{blockSize}{Neighborhood size.}
\cvarg{ksize}{Aperture parameter for the Sobel operator.}
\cvarg{k}{Harris detector free parameter.}
\cvarg{borderType}{Pixel extrapolation method. Only \texttt{BORDER\_REFLECT101} and \texttt{BORDER\_REPLICATE} are supported for now.}
\end{description}
See also: \cvCppCross{cornerMinEigenValue}.

\cvCppFunc{gpu::mulSpectrums}
Performs per-element multiplication of two Fourier spectrums.

\cvdefCpp{void mulSpectrums(const GpuMat\& a, const GpuMat\& b,\par
  GpuMat\& c, int flags, bool conjB=false);}

\begin{description}
\cvarg{a}{First spectrum.}
\cvarg{b}{Second spectrum. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination spectrum.}
\cvarg{flags}{Mock paramter is kept for CPU/GPU interfaces similarity.}
\cvarg{conjB}{Optional flag indicates if the second spectrum must be conjugated before the multiplcation.}
\end{description}

Only full (i.e. not packed) 32FC2 complex spectrums in the interleaved format are supported for now.

See also: \cvCppCross{mulSpectrums}.

\cvCppFunc{gpu::mulAndScaleSpectrums}
Performs per-element multiplication of two Fourier spectrums and scales the result.

\cvdefCpp{void mulAndScaleSpectrums(const GpuMat\& a, const GpuMat\& b,\par
  GpuMat\& c, int flags, float scale, bool conjB=false);}

\begin{description}
\cvarg{a}{First spectrum.}
\cvarg{b}{Second spectrum. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination spectrum.}
\cvarg{flags}{Mock paramter is kept for CPU/GPU interfaces similarity.}
\cvarg{scale}{Scale constant.}
\cvarg{conjB}{Optional flag indicates if the second spectrum must be conjugated before the multiplcation.}
\end{description}

Only full (i.e. not packed) 32FC2 complex spectrums in the interleaved format are supported for now.

See also: \cvCppCross{mulSpectrums}.

\section{Object Detection}

\cvclass{gpu::HOGDescriptor}
Histogram of Oriented Gradients descriptor and detector.

\begin{lstlisting}
struct CV_EXPORTS HOGDescriptor
{
public:
    enum { DEFAULT_WIN_SIGMA = -1 };
    enum { DEFAULT_NLEVELS = 64 };
    enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };

    HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16),
                  Size block_stride=Size(8, 8), Size cell_size=Size(8, 8),
                  int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA,
                  double threshold_L2hys=0.2, bool gamma_correction=true,
                  int nlevels=DEFAULT_NLEVELS);

    size_t getDescriptorSize() const;
    size_t getBlockHistogramSize() const;

    void setSVMDetector(const vector<float>& detector);

    static vector<float> getDefaultPeopleDetector();
    static vector<float> getPeopleDetector48x96();
    static vector<float> getPeopleDetector64x128();

    void detect(const GpuMat& img, vector<Point>& found_locations, 
                double hit_threshold=0, Size win_stride=Size(), 
                Size padding=Size());

    void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations,
                          double hit_threshold=0, Size win_stride=Size(), 
                          Size padding=Size(), double scale0=1.05, 
                          int group_threshold=2);

    void getDescriptors(const GpuMat& img, Size win_stride, 
                        GpuMat& descriptors,
                        int descr_format=DESCR_FORMAT_COL_BY_COL);

    Size win_size;
    Size block_size;
    Size block_stride;
    Size cell_size;
    int nbins;
    double win_sigma;
    double threshold_L2hys;
    bool gamma_correction;
    int nlevels;
}
\end{lstlisting}

Interfaces of all methods are kept similar to CPU HOG descriptor and detector's analogues as much as possible.

\cvCppFunc{gpu::HOGDescriptor::HOGDescriptor}
Creates HOG descriptor and detector.

\cvdefCpp{HOGDescriptor(Size win\_size=Size(64, 128), Size block\_size=Size(16, 16),\par
          Size block\_stride=Size(8, 8), Size cell\_size=Size(8, 8),\par
          int nbins=9, double win\_sigma=DEFAULT\_WIN\_SIGMA,\par
          double threshold\_L2hys=0.2, bool gamma\_correction=true,\par
          int nlevels=DEFAULT\_NLEVELS);}

\begin{description}
\cvarg{win\_size}{Detection window size. Must be aligned to block size and block stride.}
\cvarg{block\_size}{Block size in cells. Only (2,2) is supported for now.}
\cvarg{block\_stride}{Block stride. Must be a multiple of cell size.}
\cvarg{cell\_size}{Cell size. Only (8, 8) is supported for now.}
\cvarg{nbins}{Number of bins. Only 9 bins per cell is supported for now.}
\cvarg{win\_sigma}{Gaussian smoothing window parameter.}
\cvarg{threshold\_L2Hys}{L2-Hys normalization method shrinkage.}
\cvarg{gamma\_correction}{Do gamma correction preprocessing or not.}
\cvarg{nlevels}{Maximum number of detection window increases.}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::getDescriptorSize}
Returns number of coefficients required for the classification.

\cvdefCpp{size\_t getDescriptorSize() const;}

\cvCppFunc{gpu::HOGDescriptor::getBlockHistogramSize}
Returns block histogram size.

\cvdefCpp{size\_t getBlockHistogramSize() const;}

\cvCppFunc{gpu::HOGDescriptor::setSVMDetector}
Sets coefficients for the linear SVM classifier. 

\cvdefCpp{void setSVMDetector(const vector<float>\& detector);}

\cvCppFunc{gpu::HOGDescriptor::getDefaultPeopleDetector}
Returns coefficients of the classifier trained for people detection (for default window size).

\cvdefCpp{static vector<float> getDefaultPeopleDetector();}

\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector48x96}
Returns coefficients of the classifier trained for people detection (for 48x96 windows).

\cvdefCpp{static vector<float> getPeopleDetector48x96();}

\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector64x128}
Returns coefficients of the classifier trained for people detection (for 64x128 windows).

\cvdefCpp{static vector<float> getPeopleDetector64x128();}

\cvCppFunc{gpu::HOGDescriptor::detect}
Perfroms object detection without increasing detection window.

\cvdefCpp{void detect(const GpuMat\& img, vector<Point>\& found\_locations,\par
             double hit\_threshold=0, Size win\_stride=Size(),\par
             Size padding=Size());}

\begin{description}
\cvarg{img}{Source image. 8UC1 and 8UC4 types are supported for now.}
\cvarg{found\_locations}{Will contain left-top corner points of detected objects boundaries.}
\cvarg{hit\_threshold}{The threshold for the distance between features and classifying plane. Usually it's 0, and should be specfied in the detector coefficients (as the last free coefficient), but if the free coefficient is missed (it's allowed) you can specify it manually here.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::detectMultiScale}
Perfroms object detection with increasing detection window.

\cvdefCpp{void detectMultiScale(const GpuMat\& img, vector<Rect>\& found\_locations,\par
                      double hit\_threshold=0, Size win\_stride=Size(),\par
                      Size padding=Size(), double scale0=1.05,\par
                      int group\_threshold=2);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{found\_locations}{Will contain detected objects boundaries.}
\cvarg{hit\_threshold}{The threshold for the distance between features and classifying plane. See \cvCppCross{gpu::HOGDescriptor::detect} for details.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\cvarg{scale0}{Coefficient of the detection window increase.}
\cvarg{group\_threshold}{After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping.\newline
See \cvCppCross{groupRectangles}.}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::getDescriptors}
Returns block descriptors computed for the whole image. 

\cvdefCpp{void getDescriptors(const GpuMat\& img, Size win\_stride,\par
                    GpuMat\& descriptors,\par
                    int descr\_format=DESCR\_FORMAT\_COL\_BY\_COL);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{descriptors}{2D array of descriptors.}
\cvarg{descr\_format}{Descriptor storage format: 
\begin{description}
    \cvarg{DESCR\_FORMAT\_ROW\_BY\_ROW}{Row-major order.}
    \cvarg{DESCR\_FORMAT\_COL\_BY\_COL}{Column-major order.}
\end{description}}
\end{description}

\fi