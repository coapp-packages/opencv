\section{Feature Detection and Description}


\cvclass{gpu::SURF\_GPU}
Class for extracting Speeded Up Robust Features from an image.

\begin{lstlisting}
class SURF_GPU : public SURFParams_GPU
{
public:
    //! returns the descriptor size in float's (64 or 128)
    int descriptorSize() const;

    //! upload host keypoints to device memory
    static void uploadKeypoints(const vector<KeyPoint>& keypoints, 
        GpuMat& keypointsGPU);
    //! download keypoints from device to host memory
    static void downloadKeypoints(const GpuMat& keypointsGPU, 
        vector<KeyPoint>& keypoints);

    //! download descriptors from device to host memory
    static void downloadDescriptors(const GpuMat& descriptorsGPU, 
        vector<float>& descriptors);
    
    void operator()(const GpuMat& img, const GpuMat& mask, 
        GpuMat& keypoints);
    
    void operator()(const GpuMat& img, const GpuMat& mask, 
        GpuMat& keypoints, GpuMat& descriptors, 
        bool useProvidedKeypoints = false, 
        bool calcOrientation = true);

    void operator()(const GpuMat& img, const GpuMat& mask, 
        std::vector<KeyPoint>& keypoints);

    void operator()(const GpuMat& img, const GpuMat& mask, 
        std::vector<KeyPoint>& keypoints, GpuMat& descriptors, 
        bool useProvidedKeypoints = false, 
        bool calcOrientation = true);
    
    void operator()(const GpuMat& img, const GpuMat& mask, 
        std::vector<KeyPoint>& keypoints, 
        std::vector<float>& descriptors, 
        bool useProvidedKeypoints = false, 
        bool calcOrientation = true);

    GpuMat sum;
    GpuMat sumf;

    GpuMat mask1;
    GpuMat maskSum;

    GpuMat hessianBuffer;
    GpuMat maxPosBuffer;
    GpuMat featuresBuffer;
};
\end{lstlisting}

The class \texttt{SURF\_GPU} implements Speeded Up Robust Features descriptor. There is fast multi-scale Hessian keypoint detector that can be used to find the keypoints (which is the default option), but the descriptors can be also computed for the user-specified keypoints. Supports only 8 bit grayscale images.

The class \texttt{SURF\_GPU} can store results to GPU and CPU memory and provides static functions to convert results between CPU and GPU version (\texttt{uploadKeypoints}, \texttt{downloadKeypoints}, \texttt{downloadDescriptors}). CPU results has the same format as \hyperref[cv.class.SURF]{cv::SURF} results. GPU results are stored to \texttt{GpuMat}. \texttt{keypoints} matrix is one row matrix with \texttt{CV\_32FC6} type. It contains 6 float values per feature: \texttt{x, y, size, response, angle, octave}. \texttt{descriptors} matrix is $\texttt{nFeatures} \times \texttt{descriptorSize}$ matrix with \texttt{CV\_32FC1} type.

The class \texttt{SURF\_GPU} uses some buffers and provides access to it. All buffers can be safely released between function calls. 

See also: \hyperref[cv.class.SURF]{cv::SURF}.


\cvclass{gpu::BruteForceMatcher\_GPU}
Brute-force descriptor matcher. For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one. This descriptor matcher supports masking permissible matches between descriptor sets.

\begin{lstlisting}
template<class Distance>
class BruteForceMatcher_GPU
{
public:
    // Add descriptors to train descriptor collection.
    void add(const std::vector<GpuMat>& descCollection);

    // Get train descriptors collection.
    const std::vector<GpuMat>& getTrainDescriptors() const;

    // Clear train descriptors collection.
    void clear();

    // Return true if there are not train descriptors in collection.
    bool empty() const;

    // Return true if the matcher supports mask in match methods.
    bool isMaskSupported() const;

    void matchSingle(const GpuMat& queryDescs, const GpuMat& trainDescs,
        GpuMat& trainIdx, GpuMat& distance,
        const GpuMat& mask = GpuMat());

    static void matchDownload(const GpuMat& trainIdx, 
        const GpuMat& distance, std::vector<DMatch>& matches);

    void match(const GpuMat& queryDescs, const GpuMat& trainDescs, 
        std::vector<DMatch>& matches, const GpuMat& mask = GpuMat());

    void makeGpuCollection(GpuMat& trainCollection, GpuMat& maskCollection,
        const vector<GpuMat>& masks = std::vector<GpuMat>());

    void matchCollection(const GpuMat& queryDescs, 
        const GpuMat& trainCollection,
        GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance,
        const GpuMat& maskCollection);

    static void matchDownload(const GpuMat& trainIdx, GpuMat& imgIdx, 
        const GpuMat& distance, std::vector<DMatch>& matches);

    void match(const GpuMat& queryDescs, std::vector<DMatch>& matches,
        const std::vector<GpuMat>& masks = std::vector<GpuMat>());

    void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,
        GpuMat& trainIdx, GpuMat& distance, GpuMat& allDist, int k, 
        const GpuMat& mask = GpuMat());

    static void knnMatchDownload(const GpuMat& trainIdx, 
        const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, 
        bool compactResult = false);

    void knnMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,
        std::vector< std::vector<DMatch> >& matches, int k, 
        const GpuMat& mask = GpuMat(), bool compactResult = false);
        
    void knnMatch(const GpuMat& queryDescs, 
        std::vector< std::vector<DMatch> >& matches, int knn,
        const std::vector<GpuMat>& masks = std::vector<GpuMat>(), 
        bool compactResult = false );

    void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,
        GpuMat& trainIdx, GpuMat& nMatches, GpuMat& distance, 
        float maxDistance, const GpuMat& mask = GpuMat());

    static void radiusMatchDownload(const GpuMat& trainIdx, 
        const GpuMat& nMatches, const GpuMat& distance, 
        std::vector< std::vector<DMatch> >& matches, 
        bool compactResult = false);

    void radiusMatch(const GpuMat& queryDescs, const GpuMat& trainDescs,
        std::vector< std::vector<DMatch> >& matches, float maxDistance,
        const GpuMat& mask = GpuMat(), bool compactResult = false);

    void radiusMatch(const GpuMat& queryDescs, 
        std::vector< std::vector<DMatch> >& matches, float maxDistance,
        const std::vector<GpuMat>& masks = std::vector<GpuMat>(), 
        bool compactResult = false);

private:
    std::vector<GpuMat> trainDescCollection;
};
\end{lstlisting}

The class \texttt{BruteForceMatcher\_GPU} has the similar interface to class \hyperref[cv.class.DescriptorMatcher]{cv::DescriptorMatcher}. It has two groups of match methods: for matching descriptors of one image with other image or with image set. Also all functions have alternative: save results to GPU memory or to CPU memory.

\texttt{Distance} template parameter is kept for CPU/GPU interfaces similarity. \texttt{BruteForceMatcher\_GPU} supports only \texttt{L1<float>} and \texttt{L2<float>} distance types.

See also: \hyperref[cv.class.DescriptorMatcher]{cv::DescriptorMatcher}, \hyperref[cv.class.BruteForceMatcher]{cv::BruteForceMatcher}.


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::match}\label{cppfunc.gpu.BruteForceMatcher.match}
Finds the best match for each descriptor from a query set with train descriptors.

\cvdefCpp{
void match(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par std::vector<DMatch>\& matches, \par const GpuMat\& mask = GpuMat());\newline
void match(const GpuMat\& queryDescs, \par std::vector<DMatch>\& matches, \par const std::vector<GpuMat>\& masks = std::vector<GpuMat>());
}

See also: \cvCppCross{DescriptorMatcher::match}.


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::matchSingle}\label{cppfunc.gpu.BruteForceMatcher.matchSingle}
Finds the best match for each query descriptor. Results will be stored to GPU memory.

\cvdefCpp{
void matchSingle(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par GpuMat\& trainIdx, \par GpuMat\& distance, \par const GpuMat\& mask = GpuMat());
}

\begin{description}
\cvarg{queryDescs} {Query set of descriptors.}
\cvarg{trainDescs} {Train set of descriptors. This will not be added to train descriptors collection stored in class object.}
\cvarg{trainIdx} {One row \texttt{CV\_32SC1} matrix. Will contain the best train index for each query. If some query descriptors are masked out in \texttt{mask} it will contain -1.}
\cvarg{distance} {One row \texttt{CV\_32FC1} matrix. Will contain the best distance for each query. If some query descriptors are masked out in \texttt{mask} it will contain \texttt{FLT\_MAX}.}
\cvarg{mask}{Mask specifying permissible matches between input query and train matrices of descriptors.}
\end{description}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::matchCollection}\label{cppfunc.gpu.BruteForceMatcher.matchCollection}
Find the best match for each query descriptor from train collection. Results will be stored to GPU memory.

\cvdefCpp{
void matchCollection(const GpuMat\& queryDescs, \par const GpuMat\& trainCollection, \par GpuMat\& trainIdx, \par GpuMat\& imgIdx, \par GpuMat\& distance, \par const GpuMat\& maskCollection);
}

\begin{description}
\cvarg{queryDescs} {Query set of descriptors.}
\cvarg{trainCollection} {\texttt{GpuMat} containing train collection. It can be obtained from train descriptors collection that was set using \texttt{add} method by \hyperref[cppfunc.gpu.BruteForceMatcher.makeGpuCollection]{makeGpuCollection}. Or it can contain user defined collection. It must be one row matrix, each element is a \texttt{DevMem2D} that points to one train descriptors matrix.}
\cvarg{trainIdx} {One row \texttt{CV\_32SC1} matrix. Will contain the best train index for each query. If some query descriptors are masked out in \texttt{maskCollection} it will contain -1.}
\cvarg{imgIdx} {One row \texttt{CV\_32SC1} matrix. Will contain image train index for each query. If some query descriptors are masked out in \texttt{maskCollection} it will contain -1.}
\cvarg{distance} {One row \texttt{CV\_32FC1} matrix. Will contain the best distance for each query. If some query descriptors are masked out in \texttt{maskCollection} it will contain \texttt{FLT\_MAX}.}
\cvarg{maskCollection}{\texttt{GpuMat} containing set of masks. It can be obtained from \texttt{std::vector<GpuMat>} by \hyperref[cppfunc.gpu.BruteForceMatcher.makeGpuCollection]{makeGpuCollection}. Or it can contain user defined mask set. It must be empty matrix or one row matrix, each element is a \texttt{PtrStep} that points to one mask.}
\end{description}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::makeGpuCollection}\label{cppfunc.gpu.BruteForceMatcher.makeGpuCollection}
Makes gpu collection of train descriptors and masks in suitable format for \hyperref[cppfunc.gpu.BruteForceMatcher.matchCollection]{matchCollection} function.

\cvdefCpp{
void makeGpuCollection(GpuMat\& trainCollection, \par GpuMat\& maskCollection, \par const vector<GpuMat>\& masks = std::vector<GpuMat>());
}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::matchDownload}\label{cppfunc.gpu.BruteForceMatcher.matchDownload}
Downloads \texttt{trainIdx}, \texttt{imgIdx} and \texttt{distance} matrices obtained via \hyperref[cppfunc.gpu.BruteForceMatcher.matchSingle]{matchSingle} or \hyperref[cppfunc.gpu.BruteForceMatcher.matchCollection]{matchCollection} to CPU vector with \hyperref[cv.class.DMatch]{cv::DMatch}.

\cvdefCpp{
void matchDownload(const GpuMat\& trainIdx, \par const GpuMat\& distance, \par std::vector<DMatch>\& matches); \newline
void matchDownload(const GpuMat\& trainIdx, \par GpuMat\& imgIdx, \par const GpuMat\& distance, \par std::vector<DMatch>\& matches);
}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::knnMatch}\label{cppfunc.gpu.BruteForceMatcher.knnMatch}
Finds the k best matches for each descriptor from a query set with train descriptors. Found k (or less if not possible) matches are returned in distance increasing order.

\cvdefCpp{
void knnMatch(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par std::vector< std::vector<DMatch> >\& matches, \par int k, \par const GpuMat\& mask = GpuMat(), \par bool compactResult = false);
}
\cvdefCpp{
void knnMatch(const GpuMat\& queryDescs, \par std::vector< std::vector<DMatch> >\& matches, \par int k, \par const std::vector<GpuMat>\& masks = std::vector<GpuMat>(), \par bool compactResult = false );
}

See also: \cvCppCross{DescriptorMatcher::knnMatch}.


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::knnMatch}\label{cppfunc.gpu.BruteForceMatcher.knnMatchSingle}
Finds the k best matches for each descriptor from a query set with train descriptors. Found k (or less if not possible) matches are returned in distance increasing order. Results will be stored to GPU memory.

\cvdefCpp{
void knnMatch(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par GpuMat\& trainIdx, \par GpuMat\& distance, \par GpuMat\& allDist, \par int k, \par const GpuMat\& mask = GpuMat());
}

\begin{description}
\cvarg{queryDescs} {Query set of descriptors.}
\cvarg{trainDescs} {Train set of descriptors. This will not be added to train descriptors collection stored in class object.}
\cvarg{trainIdx} {Matrix with $\texttt{nQueries} \times \texttt{k}$ size and \texttt{CV\_32SC1} type. \texttt{trainIdx.at<int>(queryIdx, i)} will contain index of the i'th best trains. If some query descriptors are masked out in \texttt{mask} it will contain -1.}
\cvarg{distance} {Matrix with $\texttt{nQuery} \times \texttt{k}$ and \texttt{CV\_32FC1} type. Will contain distance for each query and the i'th best trains. If some query descriptors are masked out in \texttt{mask} it will contain \texttt{FLT\_MAX}.}
\cvarg{allDist} {Buffer to store all distances between query descriptors and train descriptors. It will have $\texttt{nQuery} \times \texttt{nTrain}$ size and \texttt{CV\_32FC1} type. \texttt{allDist.at<float>(queryIdx, trainIdx)} will contain \texttt{FLT\_MAX}, if \texttt{trainIdx} is one from k best, otherwise it will contain distance between \texttt{queryIdx} and \texttt{trainIdx} descriptors.}
\cvarg{k}{Number of the best matches will be found per each query descriptor (or less if it's not possible).}
\cvarg{mask}{Mask specifying permissible matches between input query and train matrices of descriptors.}
\end{description}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::knnMatchDownload}\label{cppfunc.gpu.BruteForceMatcher.knnMatchDownload}
Downloads \texttt{trainIdx} and \texttt{distance} matrices obtained via \hyperref[cppfunc.gpu.BruteForceMatcher.knnMatchSingle]{knnMatch} to CPU vector with \hyperref[cv.class.DMatch]{cv::DMatch}. If \texttt{compactResult} is true \texttt{matches} vector will not contain matches for fully masked out query descriptors.

\cvdefCpp{
void knnMatchDownload(const GpuMat\& trainIdx, \par const GpuMat\& distance, \par std::vector< std::vector<DMatch> >\& matches, \par bool compactResult = false);
}


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::radiusMatch}\label{cppfunc.gpu.BruteForceMatcher.radiusMatch}
Finds the best matches for each query descriptor which have distance less than given threshold. Found matches are returned in distance increasing order.

\cvdefCpp{
void radiusMatch(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par std::vector< std::vector<DMatch> >\& matches, \par float maxDistance, \par const GpuMat\& mask = GpuMat(), \par bool compactResult = false);
}
\cvdefCpp{
void radiusMatch(const GpuMat\& queryDescs, \par std::vector< std::vector<DMatch> >\& matches, \par float maxDistance, \par const std::vector<GpuMat>\& masks = std::vector<GpuMat>(), \par bool compactResult = false);
}

This function works only on devices with Compute Capability $>=$ 1.1.

See also: \cvCppCross{DescriptorMatcher::radiusMatch}.


\cvfunc{cv::gpu::BruteForceMatcher\_GPU::radiusMatch}\label{cppfunc.gpu.BruteForceMatcher.radiusMatchSingle}
Finds the best matches for each query descriptor which have distance less than given threshold. Results will be stored to GPU memory.

\cvdefCpp{
void radiusMatch(const GpuMat\& queryDescs, \par const GpuMat\& trainDescs, \par GpuMat\& trainIdx, \par GpuMat\& nMatches, \par GpuMat\& distance, \par float maxDistance, \par const GpuMat\& mask = GpuMat());
}

\begin{description}
\cvarg{queryDescs} {Query set of descriptors.}
\cvarg{trainDescs} {Train set of descriptors. This will not be added to train descriptors collection stored in class object.}
\cvarg{trainIdx} {\texttt{trainIdx.at<int>(queryIdx, i)} will contain i'th train index \newline\texttt{(i < min(nMatches.at<unsigned int>(0, queryIdx), trainIdx.cols)}. If \texttt{trainIdx} is empty, it will be created with size $\texttt{nQuery} \times \texttt{nTrain}$. Or it can be allocated by user (it must have \texttt{nQuery} rows and \texttt{CV\_32SC1} type). Cols can be less than \texttt{nTrain}, but it can be that matcher won't find all matches, because it haven't enough memory to store results.}
\cvarg{nMatches} {\texttt{nMatches.at<unsigned int>(0, queryIdx)} will contain matches count for \texttt{queryIdx}. Carefully, \texttt{nMatches} can be greater than \texttt{trainIdx.cols} - it means that matcher didn't find all matches, because it didn't have enough memory.}
\cvarg{distance} {\texttt{distance.at<int>(queryIdx, i)} will contain i'th distance \newline\texttt{(i < min(nMatches.at<unsigned int>(0, queryIdx), trainIdx.cols)}. If \texttt{trainIdx} is empty, it will be created with size $\texttt{nQuery} \times \texttt{nTrain}$. Otherwise it must be also allocated by user (it must have the same size as \texttt{trainIdx} and \texttt{CV\_32FC1} type).}
\cvarg{maxDistance}{Distance threshold.}
\cvarg{mask}{Mask specifying permissible matches between input query and train matrices of descriptors.}
\end{description}

In contrast to \hyperref[cppfunc.gpu.BruteForceMatcher.radiusMatch]{cv::gpu::BruteForceMather\_GPU::radiusMatch} results are not sorted by distance increasing order.

This function works only on devices with Compute Capability $>=$ 1.1.

\cvfunc{cv::gpu::BruteForceMatcher\_GPU::radiusMatchDownload}\label{cppfunc.gpu.BruteForceMatcher.radiusMatchDownload}
Downloads \texttt{trainIdx}, \texttt{nMatches} and \texttt{distance} matrices obtained via \hyperref[cppfunc.gpu.BruteForceMatcher.radiusMatchSingle]{radiusMatch} to CPU vector with \hyperref[cv.class.DMatch]{cv::DMatch}. If \texttt{compactResult} is true \texttt{matches} vector will not contain matches for fully masked out query descriptors.

\cvdefCpp{
void radiusMatchDownload(const GpuMat\& trainIdx, \par const GpuMat\& nMatches, \par const GpuMat\& distance, \par std::vector< std::vector<DMatch> >\& matches, \par bool compactResult = false);
}
