
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                                    %
%                                        C++                                         %
%                                                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifCpp
\section{Input/Output}
\subsection{Images}
Load an image from a file:
\begin{lstlisting}
Mat img = imread(filename);
\end{lstlisting}
If you read a jpg file, a 3 channel image is created by default. If you need a grayscale image, use:
\begin{lstlisting}
Mat img = imread(filename, 0);
\end{lstlisting}
Save an image to a file:
\begin{lstlisting}
Mat img = imwrite(filename);
\end{lstlisting}
\subsection{XML/YAML}

\section{Basic operations with images}
\subsection{Accessing pixel intensity values}
In order to get pixel intensity value, you have to know the type of an image and the number of channels. Here is an example for a single channel grey scale image (type 8UC1) and pixel coordinates x and y:
\begin{lstlisting}
Scalar intensity = img.at<uchar>(x, y);
\end{lstlisting}
\texttt{intensity.val[0]} contains a value from 0 to 255. 
Now let us consider a 3 channel image with \texttt{bgr} color ordering (the default format returned by imread):
\begin{lstlisting}
Vec3b intensity = img.at<Vec3b>(x, y);
uchar blue = intensity.val[0];
uchar green = intensity.val[1];
uchar red = intensity.val[2];
\end{lstlisting}
You can use the same method for floating-point images (for example, you can get such an image by running Sobel on a 3 channel image):
\begin{lstlisting}
Vec3f intensity = img.at<Vec3f>(x, y);
float blue = intensity.val[0];
float green = intensity.val[1];
float red = intensity.val[2];
\end{lstlisting}
The same method can be used to change pixel intensities:
\begin{lstlisting}
img.at<uchar>(x, y) = 128;
\end{lstlisting}


There are functions in OpenCV, especially from calib3d module, such as \texttt{projectPoints}, that take an array of 2D or 3D points in the form of \texttt{Mat}. Matrix should contain exactly one column, each row corresponds to a point, matrix type should be 32FC2 or 32FC3 correspondingly. Such a matrix can be easily constructed from std::vector:
\begin{lstlisting}
vector<Point2f> points;
//... fill the array
Mat pointsMat = Mat(points);
\end{lstlisting}
One can access a point in this matrix using the same method \texttt{Mat::at}:
\begin{lstlisting}
Point2f point = pointsMat.at<Point2f>(i, 0);
\end{lstlisting}

\subsection{Memory management and reference counting}
\texttt{Mat} is a structure that keeps matrix/image characteristics (rows and columns number, data type etc) and a pointer to data. So nothing prevents us from having several instances of \texttt{Mat} corresponding to the same data. A \texttt{Mat} keeps a reference count that tells if data has to be deallocated when a particular instance of \texttt{Mat} is destroyed. Here is an example of creating two matrices without copying data:
\begin{lstlisting}
std::vector<Point3f> points;
// .. fill the array
Mat pointsMat = Mat(points).reshape(1);
\end{lstlisting}
As a result we get a 32FC1 matrix with 3 columns instead of 32FC3 matrix with 1 column. \texttt{pointsMat} uses data from \texttt{points} and will not deallocate the memory when destroyed. In this particular instance, however, developer has to make sure that lifetime of \texttt{points} is longer than of \texttt{pointsMat}. 
If we need to copy the data, this is done using, for example, \texttt{Mat::copyTo} or \texttt{Mat::clone}:
\begin{lstlisting}
Mat img = imread("image.jpg");
Mat img1 = img.clone();
\end{lstlisting}
To the contrary with C API where an output image had to be created by developer, an empty output \texttt{Mat} can be supplied to each function. Each implementation calls \texttt{Mat::create} for a destination matrix. This method allocates data for a matrix if it is empty. If it is not empty and has the correct size and type, the method does nothing. If, however, size or type are different from input arguments, the data is deallocated (and lost) and a new data is allocated. For example:
\begin{lstlisting}
Mat img = imread("image.jpg");
Mat sobelx;
Sobel(img, sobelx, CV_32F, 1, 0);
\end{lstlisting}

\subsection{Primitive operations}
There is a number of convenient operators defined on a matrix. For example, here is how we can make a black image from an existing greyscale image \texttt{img}:
\begin{lstlisting}
img = Scalar(0);
\end{lstlisting}
Selecting a region of interest:
\begin{lstlisting}
Rect r(10, 10, 100, 100);
Mat smallImg = img(r);
\end{lstlisting}
A convertion from \texttt{Mat} to C API data structures:
\begin{lstlisting}
Mat img = imread("image.jpg");
IplImage img1 = img;
CvMat m = img;
\end{lstlisting}
Note that there is no data copying here. 

Conversion from color to grey scale:
\begin{lstlisting}
Mat img = imread("image.jpg"); // loading a 8UC3 image
Mat grey;
cvtColor(img, grey, CV_BGR2GRAY);
\end{lstlisting}
Change image type from 8UC1 to 32FC1:
\begin{lstlisting}
convertTo(src, dst, CV_32F);
\end{lstlisting}

\subsection{Visualizing images}
It is very useful to see indermediate results of your algorithm during development process. OpenCV provides a convenient way of visualizing images. A 8U image can be shown using:
\begin{lstlisting}
Mat img = imread("image.jpg");

namedWindow("image", CV_WINDOW_AUTOSIZE);
imshow("image", img);
waitKey();
\end{lstlisting}
A call to waitKey() starts a message passing cycle that waits for a key stroke in the \texttt{"image"} window. A 32F image needs to be converted to 8U type. For example:
\begin{lstlisting}
Mat img = imread("image.jpg");
Mat grey;
cvtColor(img, grey, CV_BGR2GREY);

Mat sobelx;
Sobel(grey, sobelx, CV_32F, 1, 0);

double minVal, maxVal;
minMaxLoc(sobelx, &minVal, &maxVal); //find minimum and maximum intensities
Mat draw;
sobelx.convertTo(draw, CV_8U, 255.0/(maxVal - minVal), -minVal);

namedWindow("image", CV_WINDOW_AUTOSIZE);
imshow("image", draw);
waitKey();
\end{lstlisting}


\fi