\section{Per-element Operations.}


\cvCppFunc{gpu::add}
Computes matrix-matrix or matrix-scalar sum.

\cvdefCpp{void add(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_32SC1} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void add(const GpuMat\& a, const Scalar\& sc, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix. \texttt{CV\_32FC1} and \texttt{CV\_32FC2} matrixes are supported for now.}
\cvarg{b}{Source scalar to be added to the source matrix.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{add}.


\cvCppFunc{gpu::subtract}
Subtracts matrix from another matrix (or scalar from matrix).

\cvdefCpp{void subtract(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_32SC1} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void subtract(const GpuMat\& a, const Scalar\& sc, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix.  \texttt{CV\_32FC1} and \texttt{CV\_32FC2} matrixes are supported for now.}
\cvarg{b}{Scalar to be subtracted from the source matrix \texttt{a}.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{subtract}.


\cvCppFunc{gpu::multiply}
Computes per-element product of two matrices (or of matrix and scalar).

\cvdefCpp{void multiply(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_32SC1} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destionation matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void multiply(const GpuMat\& a, const Scalar\& sc, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix.  \texttt{CV\_32FC1} and \texttt{CV\_32FC2} matrixes are supported for now.}
\cvarg{b}{Scalar to be multiplied by.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{multiply}.


\cvCppFunc{gpu::divide}
Performs per-element division of two matrices (or division of matrix by scalar).

\cvdefCpp{void divide(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_32SC1} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destionation matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void divide(const GpuMat\& a, const Scalar\& sc, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix.  \texttt{CV\_32FC1} and \texttt{CV\_32FC2} matrixes are supported for now.}
\cvarg{b}{Scalar to be divided by.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{divide}.


\cvCppFunc{gpu::exp}
Computes exponent of each matrix element.

\cvdefCpp{void exp(const GpuMat\& a, GpuMat\& b);}
\begin{description}
\cvarg{a}{Source matrix. \texttt{CV\_32FC1} matrixes are supported for now.}
\cvarg{b}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{exp}.


\cvCppFunc{gpu::log}
Computes natural logarithm of absolute value of each matrix element.

\cvdefCpp{void log(const GpuMat\& a, GpuMat\& b);}
\begin{description}
\cvarg{a}{Source matrix. \texttt{CV\_32FC1} matrixes are supported for now.}
\cvarg{b}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{log}.


\cvCppFunc{gpu::absdiff}
Computes per-element absolute difference of two matrices (or of matrix and scalar).

\cvdefCpp{void absdiff(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_32SC1} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destionation matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void absdiff(const GpuMat\& a, const Scalar\& s, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix. \texttt{CV\_32FC1} matrixes are supported for now.}
\cvarg{b}{Scalar to be multiplied by.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{absdiff}.


\cvCppFunc{gpu::compare}
Compares elements of two matrices.

\cvdefCpp{void compare(const GpuMat\& a, const GpuMat\& b, GpuMat\& c, int cmpop);}
\begin{description}
\cvarg{a}{First source matrix. \texttt{CV\_8UC4} and \texttt{CV\_32FC1} matrices are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination matrix. Will have the same size as \texttt{a} and be \texttt{CV\_8UC1} type.}
\cvarg{cmpop}{Flag specifying the relation between the elements to be checked:
\begin{description}
\cvarg{CMP\_EQ}{$=$}
\cvarg{CMP\_GT}{$>$}
\cvarg{CMP\_GE}{$\ge$}
\cvarg{CMP\_LT}{$<$}
\cvarg{CMP\_LE}{$\le$}
\cvarg{CMP\_NE}{$\ne$}
\end{description}
}
\end{description}

See also: \cvCppCross{compare}.


\cvfunc{cv::gpu::bitwise\_not}\label{cppfunc.gpu.bitwise.not}
Performs per-element bitwise inversion.

\cvdefCpp{void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.not]{cv::bitwise\_not}.


\cvfunc{cv::gpu::bitwise\_or}\label{cppfunc.gpu.bitwise.or}
Performs per-element bitwise disjunction of two matrices.

\cvdefCpp{void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.or]{cv::bitwise\_or}.


\cvfunc{cv::gpu::bitwise\_and}\label{cppfunc.gpu.bitwise.and}
Performs per-element bitwise conjunction of two matrices.

\cvdefCpp{void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.and]{cv::bitwise\_and}.


\cvfunc{cv::gpu::bitwise\_xor}\label{cppfunc.gpu.bitwise.xor}
Performs per-element bitwise "exclusive or" of two matrices.

\cvdefCpp{void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.xor]{cv::bitwise\_xor}.


\cvCppFunc{gpu::min}
Computes per-element minimum of two matrices (or of matrix and scalar).

\cvdefCpp{void min(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst);\newline
void min(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

\cvdefCpp{void min(const GpuMat\& src1, double src2, GpuMat\& dst);\newline
void min(const GpuMat\& src1, double src2, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src1}{Source matrix.}
\cvarg{src2}{Scalar to be compared with.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{min}.


\cvCppFunc{gpu::max}
Computes per-element maximum of two matrices (or of matrix and scalar).

\cvdefCpp{void max(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst);\newline
void max(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

\cvdefCpp{void max(const GpuMat\& src1, double src2, GpuMat\& dst);\newline
void max(const GpuMat\& src1, double src2, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src1}{Source matrix.}
\cvarg{src2}{Scalar to be compared with.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{max}.